use crate::lower::*;

// if calc_length is true, the function assumes that only Field::Expr inputs are given.
// It then stores the length of the table in t[0].

// start_node is a node that should be prepended to the argument list (generated by foo:bar() function calls)
pub(in crate::lower) fn lower_table(fields: &[Field], start_node: Option<Node>, calc_length: bool, ctxt: &mut Ctxt) -> Node {
    let t = mk_table(ctxt);

    if let Some(n) = start_node {
        push_st(ir::Statement::Store(t, ctxt.one, n), ctxt);
    }

    if calc_length && fields.is_empty() {
        let len = match start_node {
            Some(_) => ctxt.one,
            None => ctxt.zero,
        };
        push_st(ir::Statement::Store(t, ctxt.zero, len), ctxt);
        return t;
    }

    let mut counter = 1 + start_node.is_some() as usize; // the next Field::Expr id.
    for (i, f) in fields.iter().enumerate() {
        match f {
            Field::Expr(expr) => {
                if i == fields.len() - 1 {
                    push_last_table_expr(t, counter, expr, calc_length, ctxt);
                } else {
                    let idx = mk_num(counter as f64, ctxt);

                    counter += 1;
                    let val = lower_expr1(&expr, ctxt);
                    push_st(ir::Statement::Store(t, idx, val), ctxt);
                }
            },
            Field::NameToExpr(name, expr) => {
                assert_eq!(calc_length, false);

                let idx = ir::Expr::Str(name.clone());
                let idx = mk_compute(idx, ctxt);

                let val = lower_expr1(expr, ctxt);

                push_st(ir::Statement::Store(t, idx, val), ctxt);
            },
            Field::ExprToExpr(idx, val) => {
                assert_eq!(calc_length, false);

                let idx = lower_expr1(idx, ctxt);
                let val = lower_expr1(val, ctxt);

                push_st(ir::Statement::Store(t, idx, val), ctxt);
            },
        }
    }

    t
}


// pushes expr to the table as the last element of a table constructor.
// counter == the next Field::Expr id.
fn push_last_table_expr(t: Node, counter: usize, expr: &Expr, calc_length: bool, ctxt: &mut Ctxt) {
    let (val, tabled) = lower_expr(expr, ctxt);
    if tabled {
        // `orig_t_len = #t`
        let orig_t_len = mk_num((counter-1) as f64, ctxt);

        // `len = val[0]`
        let len = mk_compute(ir::Expr::Index(val, ctxt.zero), ctxt);

        // `local i = 1`
        let i_var = mk_table_with(ctxt.one, ctxt);

        let body = ctxt.in_block(|ctxt| {
            // `loop {`

            // `if i > len: break`
            let i = mk_compute(ir::Expr::Index(i_var, ctxt.one), ctxt);
            let cond = ir::Expr::BinOp(ir::BinOpKind::Gt, i, len);
            let cond = mk_compute(cond, ctxt);
            let brk = ir::Statement::Break;
            push_st(ir::Statement::If(cond, vec![brk], Vec::new()), ctxt);

            // `t[i+orig_t_len] = val[i]`
            let r = mk_compute(ir::Expr::Index(val, i), ctxt);
            let idx = ir::Expr::BinOp(ir::BinOpKind::Plus, i, orig_t_len.clone());
            let idx = mk_compute(idx, ctxt);
            let store = ir::Statement::Store(t, idx, r);
            push_st(store, ctxt);

            // `i = i + 1`
            let r = ir::Expr::BinOp(ir::BinOpKind::Plus, i, ctxt.one);
            let r = mk_compute(r, ctxt);
            let store = ir::Statement::Store(i_var, ctxt.one, r);
            push_st(store, ctxt);

            // `}`
        });

        push_st(ir::Statement::Loop(body), ctxt);

        if calc_length {
            // `outlength = i + (orig_t_len - 1)`
            let i = ir::Expr::Index(i_var, ctxt.one);
            let i = mk_compute(i, ctxt);

            let x = ir::Expr::BinOp(ir::BinOpKind::Plus, i, mk_num(counter as f64 - 2.0, ctxt));
            let x = mk_compute(x, ctxt);

            push_st(ir::Statement::Store(t, ctxt.zero, x), ctxt);
        }
    } else {
        let idx = mk_num(counter as f64, ctxt);
        push_st(ir::Statement::Store(t, idx, val), ctxt);

        if calc_length {
            let len = idx; // length of array is the same as the highest index.
            push_st(ir::Statement::Store(t, ctxt.zero, len), ctxt);
        }
    }
}

