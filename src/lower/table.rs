use crate::lower::*;

// if calc_length is true, the function assumes that only Field::Expr inputs are given.
// It then stores the length of the table in t[0].

// start_node is a node that should be prepended to the argument list (generated by foo:bar() function calls)
pub(in crate::lower) fn lower_table(fields: &[Field], start_node: Option<Node>, calc_length: bool, ctxt: &mut Ctxt) -> Node {
    let t = mk_table(ctxt);

    if let Some(n) = start_node {
        ctxt.push_store(t, ctxt.one, n);
    }

    if calc_length && fields.is_empty() {
        let len = match start_node {
            Some(_) => ctxt.one,
            None => ctxt.zero,
        };
        ctxt.push_store(t, ctxt.zero, len);
        return t;
    }

    let mut counter = 1 + start_node.is_some() as usize; // the next Field::Expr id.
    for (i, f) in fields.iter().enumerate() {
        match f {
            Field::Expr(expr) => {
                if i == fields.len() - 1 {
                    push_last_table_expr(t, counter, expr, calc_length, ctxt);
                } else {
                    let idx = mk_num(counter as f64, ctxt);

                    counter += 1;
                    let val = lower_expr1(&expr, ctxt);
                    ctxt.push_store(t, idx, val);
                }
            },
            Field::NameToExpr(name, expr) => {
                assert_eq!(calc_length, false);

                let idx = ir::Expr::Str(name.clone());
                let idx = ctxt.push_compute(idx);

                let val = lower_expr1(expr, ctxt);

                ctxt.push_store(t, idx, val);
            },
            Field::ExprToExpr(idx, val) => {
                assert_eq!(calc_length, false);

                let idx = lower_expr1(idx, ctxt);
                let val = lower_expr1(val, ctxt);

                ctxt.push_store(t, idx, val);
            },
        }
    }

    t
}


// pushes expr to the table as the last element of a table constructor.
// counter == the next Field::Expr id.
fn push_last_table_expr(t: Node, counter: usize, expr: &Expr, calc_length: bool, ctxt: &mut Ctxt) {
    let (val, tabled) = lower_expr(expr, ctxt);
    if tabled {
        // `orig_t_len = #t`
        let orig_t_len = mk_num((counter-1) as f64, ctxt);

        // `len = val[0]`
        let len = ctxt.push_compute(ir::Expr::Index(val, ctxt.zero));

        // `local i = 1`
        let i_var = mk_table_with(ctxt.one, ctxt);

        let body = ctxt.in_block(|ctxt| {
            // `loop {`

            // `if i > len: break`
            let i = ctxt.push_compute(ir::Expr::Index(i_var, ctxt.one));
            let cond = ir::Expr::BinOp(ir::BinOpKind::Gt, i, len);
            let cond = ctxt.push_compute(cond);

            let then_body = ctxt.in_block(|ctxt| ctxt.push_st(ir::Statement::Break));
            let else_body = ctxt.empty_block();
            ctxt.push_st(ir::Statement::If(cond, then_body, else_body));

            // `t[i+orig_t_len] = val[i]`
            let r = ctxt.push_compute(ir::Expr::Index(val, i));
            let idx = ir::Expr::BinOp(ir::BinOpKind::Plus, i, orig_t_len.clone());
            let idx = ctxt.push_compute(idx);
            ctxt.push_store(t, idx, r);

            // `i = i + 1`
            let r = ir::Expr::BinOp(ir::BinOpKind::Plus, i, ctxt.one);
            let r = ctxt.push_compute(r);
            ctxt.push_store(i_var, ctxt.one, r);

            // `}`
        });

        ctxt.push_st(ir::Statement::Loop(body));

        if calc_length {
            // `outlength = i + (orig_t_len - 1)`
            let i = ir::Expr::Index(i_var, ctxt.one);
            let i = ctxt.push_compute(i);

            let x = ir::Expr::BinOp(ir::BinOpKind::Plus, i, mk_num(counter as f64 - 2.0, ctxt));
            let x = ctxt.push_compute(x);

            ctxt.push_store(t, ctxt.zero, x);
        }
    } else {
        let idx = mk_num(counter as f64, ctxt);
        ctxt.push_store(t, idx, val);

        if calc_length {
            let len = idx; // length of array is the same as the highest index.
            ctxt.push_store(t, ctxt.zero, len);
        }
    }
}

